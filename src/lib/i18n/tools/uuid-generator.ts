export const uuidGeneratorTranslations = {
    en: {
        name: "UUID Generator",
        description: "Generate UUID v1 and v4 unique identifiers",
        category: "Developer",
        generate: "Generate",
        bulkGenerate: "Bulk Generate",
        generateBulk: "Generate Multiple UUIDs",
        page: {
            title: "UUID Generator",
            subtitle: "Generate unique identifiers (UUID v1 and v4)",
            whatIs: "What is UUID?",
            whatIsDesc:
                "UUID (Universally Unique Identifier), also known as GUID (Globally Unique Identifier), is a 128-bit standardized identifier used extensively in software development and distributed computing systems. First introduced in the Apollo Network Computing System (NCS) in the 1980s and later standardized by the Open Software Foundation (OSF) as part of the Distributed Computing Environment (DCE), UUID has become an essential component of modern software architecture. The current specification is defined in RFC 4122 by the Internet Engineering Task Force (IETF).",
            history: "History and Origin of UUID",
            historyDesc:
                "The concept of UUID originated in the early 1980s at Apollo Computer for their Network Computing System. The goal was to create identifiers that could be generated independently across different systems without requiring central coordination or synchronization. This revolutionary approach allowed distributed systems to generate unique identifiers locally while maintaining global uniqueness. The technology was later adopted by the Open Software Foundation and incorporated into the Distributed Computing Environment in 1990. In 2005, RFC 4122 formalized the UUID specification, establishing the standard format and generation algorithms used today. UUIDs are now ubiquitous in modern computing, from database systems and web services to mobile applications and cloud infrastructure.",
            structure: "UUID Structure and Format",
            structureDesc:
                "A UUID consists of 32 hexadecimal digits displayed in five groups separated by hyphens, following the pattern 8-4-4-4-12 (e.g., 550e8400-e29b-41d4-a716-446655440000). The 128-bit value is typically represented as a lowercase string of 36 characters including hyphens. The structure includes variant and version bits that indicate the UUID type and generation method. The variant field determines the layout of the UUID, with most modern UUIDs using RFC 4122 variant. The version field (4 bits) identifies the generation algorithm: version 1 (timestamp-based), version 3 (MD5 hash), version 4 (random), version 5 (SHA-1 hash), with version 4 being most commonly used in contemporary applications.",
            whyUse: "Why Use UUID Generator?",
            features: {
                free: "Free to use with unlimited generation",
                instant: "Instant UUID generation",
                versions: "Support UUID v1 and v4",
                bulk: "Bulk generation for multiple UUIDs",
                copy: "One-click copy to clipboard",
                secure: "Generated locally in your browser",
            },
            howToUse: "How to Use",
            steps: {
                step1: "Choose UUID version (v1 or v4)",
                step2: "Click Generate button",
                step3: "Copy the generated UUID",
                step4: "For bulk generation, select quantity and generate",
            },
            useCases: "Common Use Cases",
            useCasesList: {
                database: "Database Primary Keys: Use UUIDs as unique identifiers",
                api: "API Identifiers: Generate unique IDs for API resources",
                session: "Session IDs: Create unique session identifiers",
                file: "File Names: Generate unique file names",
                distributed: "Distributed Systems: Ensure uniqueness across systems",
            },
            versions: "UUID Versions",
            versionsList: {
                v4: {
                    title: "UUID v4 (Random-based)",
                    desc: "Version 4 UUIDs are generated using cryptographically strong pseudo-random numbers. This is the most widely adopted version in modern applications due to its simplicity and excellent uniqueness properties. With 122 random bits, the probability of collision is approximately 1 in 2^122 (5.3 x 10^36), making it statistically impossible to generate duplicates in any practical scenario. V4 UUIDs are ideal for distributed systems where coordination between nodes is impractical or impossible. Major platforms including Java's java.util.UUID, Python's uuid module, and JavaScript's crypto.randomUUID() default to version 4 generation.",
                },
                v1: {
                    title: "UUID v1 (Timestamp-based)",
                    desc: "Version 1 UUIDs incorporate the current timestamp (60-bit count of 100-nanosecond intervals since October 15, 1582) and the MAC address of the generating machine. This ensures uniqueness across both time and space. The timestamp component allows UUIDs to be sorted chronologically, which can improve database index performance. However, V1 UUIDs have privacy implications as they expose the generating machine's MAC address and creation time. They're commonly used in scenarios requiring time-ordered identifiers, such as event logging, time-series databases, and systems where chronological sorting is beneficial. Modern implementations may use random node IDs instead of MAC addresses to address privacy concerns.",
                },
            },
            performance: "UUID Performance and Efficiency",
            performanceDesc:
                "UUID generation is computationally inexpensive and can produce millions of identifiers per second on modern hardware. Version 4 generation typically requires only a cryptographic random number generator call, while version 1 needs timestamp and node ID retrieval. In database systems, UUIDs as primary keys offer excellent scalability for distributed databases and multi-master replication scenarios, eliminating the need for centralized ID generation. However, they're larger than auto-increment integers (128 bits vs 32-64 bits), which can impact storage and index performance. The random nature of V4 UUIDs can cause B-tree index fragmentation in traditional relational databases, though this is mitigated in modern database engines with UUID-optimized storage. Sequential UUIDs or ordered UUID variants (like ULID or UUID v6/v7) address this limitation while maintaining uniqueness guarantees.",
            security: "Security Considerations",
            securityDesc:
                "UUID v4 generation relies on cryptographically secure random number generators (CSPRNG) to ensure unpredictability, making them suitable for security-sensitive applications like session tokens, API keys, and password reset tokens. The astronomical entropy (2^122 possible combinations) makes brute-force attacks computationally infeasible. However, developers should note that UUIDs are not designed as secrets - they're identifiers, not authentication credentials. Version 1 UUIDs should be avoided in security contexts as they're partially predictable and leak information about generation time and hardware. For security-critical applications requiring both uniqueness and unpredictability, UUID v4 combined with proper access controls and encryption provides robust identifier management. All UUID generation on this tool occurs entirely within your browser using the Web Crypto API, ensuring your identifiers are never transmitted to external servers.",
            faq: "Frequently Asked Questions",
            faqList: {
                q1: "What is the difference between UUID v1 and v4?",
                a1: "UUID v1 generates identifiers based on timestamp (60-bit time value) and MAC address, ensuring uniqueness across time and space. The timestamp allows chronological sorting, but exposes generation time and hardware information. UUID v4 uses cryptographically strong random numbers (122 random bits) for generation, providing better privacy and unpredictability. V4 is stateless and simpler to implement, making it the preferred choice for 95% of modern applications including web services, microservices, and cloud applications.",
                q2: "Are UUIDs truly unique?",
                a2: "Yes, UUIDs provide practical uniqueness guarantees. For UUID v4, with 122 random bits, the probability of generating a duplicate is approximately 1 in 5.3 × 10^36. To put this in perspective, generating one billion UUIDs per second for 100 years would produce a collision probability of only 0.0000000000005%. UUID v1 guarantees uniqueness through timestamp precision (100-nanosecond intervals) and machine identification. While theoretically possible for collisions to occur in v4, it's statistically impossible in any real-world scenario. Major tech companies generate billions of UUIDs daily without collision issues.",
                q3: "Can I use UUID as a primary key in databases?",
                a3: "Yes, UUIDs are excellent primary keys for distributed databases and modern applications. Benefits include: (1) Client-side generation without database round-trips, (2) Merge-friendly for multi-master replication, (3) No sequential prediction vulnerability, (4) Globally unique across all tables and databases. Considerations: UUIDs are larger than integers (16 bytes vs 4-8 bytes), which increases storage and index size. Random UUIDs can cause index fragmentation in B-tree indexes. Modern solutions include UUID v6/v7 for time-ordered UUIDs, or database-specific optimizations (PostgreSQL's UUID type, MySQL's UUID_TO_BIN()). Major platforms like MongoDB, Cassandra, and DynamoDB use UUID-like identifiers as default.",
                q4: "How long is a UUID and what's the format?",
                a4: "A UUID is exactly 128 bits (16 bytes) in length. The canonical textual representation is 36 characters: 32 hexadecimal digits (0-9, a-f) plus 4 hyphens in the format 8-4-4-4-12 (example: 550e8400-e29b-41d4-a716-446655440000). The string representation uses 36 bytes of storage, while binary storage uses 16 bytes. The five groups represent: (1) time_low (8 hex digits), (2) time_mid (4 hex digits), (3) time_hi_and_version (4 hex digits), (4) clock_seq_and_reserved (4 hex digits), and (5) node (12 hex digits). Some systems use alternative representations like Base64 encoding (22 characters) for more compact URLs.",
                q5: "Is UUID generation secure and private?",
                a5: "UUID v4 generation is cryptographically secure when using proper random number generators. Our tool uses the Web Crypto API (crypto.getRandomValues()) which provides cryptographically strong random numbers suitable for security-sensitive applications. All generation occurs entirely in your browser - no data is sent to servers, ensuring complete privacy. However, important notes: (1) UUIDs are identifiers, not secrets or passwords - they can be exposed safely in URLs and APIs, (2) UUID v1 exposes timestamp and potentially MAC address, reducing privacy, (3) For authentication tokens, combine UUIDs with proper access controls and expiration, (4) UUIDs alone don't provide authentication - they must be validated server-side. For maximum security: use v4, generate server-side for tokens, implement rate limiting, and never use UUIDs as sole authentication mechanism.",
                q6: "What are the advantages of UUID over auto-increment IDs?",
                a6: "UUIDs offer several advantages: (1) Global uniqueness without coordination - can be generated independently across distributed systems, (2) No database round-trip required for ID generation, improving performance, (3) Merge-friendly for database replication and sharding, (4) Security - non-sequential nature prevents enumeration attacks, (5) Offline capability - IDs can be generated without database connection, (6) Flexibility - same ID space can be used across multiple tables and databases. Trade-offs include larger storage size, potential index fragmentation, and less human-readable format. Best for: microservices, distributed systems, public APIs, offline-first applications. Use auto-increment for: single-database systems, chronologically ordered data, storage-constrained environments.",
                q7: "How many UUIDs can be generated before collision?",
                a7: "For UUID v4 with 122 random bits, you can generate approximately 2.71 × 10^18 (2.71 quintillion) UUIDs before reaching a 50% probability of a single collision. To illustrate the scale: generating 1 trillion (10^12) UUIDs results in collision probability of only 0.0000000000005%. Even if every person on Earth generated 1 million UUIDs per second for an entire year, collision probability would remain negligible. The birthday paradox applies, but the enormous key space makes collisions statistically impossible for any practical application. UUID v1 has even stronger guarantees through timestamp precision - two UUIDs generated on different machines or at different times (>100 nanoseconds apart) are guaranteed unique.",
                q8: "Which UUID version should I choose?",
                a8: "Choose UUID v4 for 95% of use cases: web applications, APIs, microservices, session IDs, resource identifiers. It's simple, secure, and provides excellent uniqueness. Use UUID v1 when: (1) chronological sorting is important, (2) you need to extract timestamp from IDs, (3) database index performance with time-ordering is critical. Avoid v1 if privacy is a concern (exposes MAC address). Emerging alternatives: UUID v6 (time-ordered like v1 but improved), UUID v7 (Unix timestamp-based, better database performance), ULID (lexicographically sortable, URL-safe). For new projects in 2025, consider v4 for general use, v7 for database-heavy applications requiring time-ordering, or ULID for better human-readability and sorting.",
            },
        },
    },
    vi: {
        name: "Tạo UUID",
        description: "Tạo UUID v1 và v4 định danh duy nhất",
        category: "Lập Trình",
        generate: "Tạo",
        bulkGenerate: "Tạo Hàng Loạt",
        generateBulk: "Tạo Nhiều UUID",
        page: {
            title: "Tạo UUID",
            subtitle: "Tạo định danh duy nhất (UUID v1 và v4)",
            whatIs: "UUID Là Gì?",
            whatIsDesc:
                "UUID (Universally Unique Identifier - Mã định danh duy nhất toàn cầu), còn được gọi là GUID (Globally Unique Identifier), là một mã định danh chuẩn 128-bit được sử dụng rộng rãi trong phát triển phần mềm và hệ thống điện toán phân tán. Lần đầu tiên được giới thiệu trong Apollo Network Computing System (NCS) vào những năm 1980 và sau đó được chuẩn hóa bởi Open Software Foundation (OSF) như một phần của Distributed Computing Environment (DCE), UUID đã trở thành một thành phần thiết yếu của kiến trúc phần mềm hiện đại. Đặc tả hiện tại được định nghĩa trong RFC 4122 bởi Internet Engineering Task Force (IETF).",
            history: "Lịch Sử và Nguồn Gốc UUID",
            historyDesc:
                "Khái niệm UUID có nguồn gốc từ đầu những năm 1980 tại Apollo Computer cho Network Computing System của họ. Mục tiêu là tạo ra các mã định danh có thể được tạo độc lập trên các hệ thống khác nhau mà không cần điều phối hoặc đồng bộ hóa trung tâm. Cách tiếp cận cách mạng này cho phép các hệ thống phân tán tạo mã định danh duy nhất cục bộ trong khi vẫn duy trì tính duy nhất toàn cầu. Công nghệ này sau đó được Open Software Foundation áp dụng và tích hợp vào Distributed Computing Environment năm 1990. Năm 2005, RFC 4122 đã chính thức hóa đặc tả UUID, thiết lập định dạng chuẩn và thuật toán tạo được sử dụng ngày nay. UUID hiện nay có mặt khắp nơi trong điện toán hiện đại, từ hệ thống cơ sở dữ liệu và dịch vụ web đến ứng dụng di động và cơ sở hạ tầng đám mây.",
            structure: "Cấu Trúc và Định Dạng UUID",
            structureDesc:
                "UUID bao gồm 32 chữ số thập lục phân được hiển thị trong năm nhóm cách nhau bởi dấu gạch ngang, theo mẫu 8-4-4-4-12 (ví dụ: 550e8400-e29b-41d4-a716-446655440000). Giá trị 128-bit thường được biểu diễn dưới dạng chuỗi chữ thường gồm 36 ký tự bao gồm cả dấu gạch ngang. Cấu trúc bao gồm các bit variant và version cho biết loại UUID và phương thức tạo. Trường variant xác định bố cục của UUID, với hầu hết UUID hiện đại sử dụng variant RFC 4122. Trường version (4 bit) xác định thuật toán tạo: version 1 (dựa trên timestamp), version 3 (hash MD5), version 4 (ngẫu nhiên), version 5 (hash SHA-1), với version 4 được sử dụng phổ biến nhất trong các ứng dụng đương đại.",
            whyUse: "Tại Sao Dùng Tạo UUID?",
            features: {
                free: "Miễn phí không giới hạn",
                instant: "Tạo UUID tức thì",
                versions: "Hỗ trợ UUID v1 và v4",
                bulk: "Tạo hàng loạt nhiều UUID",
                copy: "Sao chép một cú nhấp",
                secure: "Tạo cục bộ trong trình duyệt",
            },
            howToUse: "Cách Sử Dụng",
            steps: {
                step1: "Chọn phiên bản UUID (v1 hoặc v4)",
                step2: "Nhấp nút Tạo",
                step3: "Sao chép UUID đã tạo",
                step4: "Để tạo hàng loạt, chọn số lượng và tạo",
            },
            useCases: "Trường Hợp Sử Dụng",
            useCasesList: {
                database: "Khóa Chính: Dùng UUID làm mã định danh duy nhất",
                api: "API: Tạo ID duy nhất cho tài nguyên API",
                session: "Session ID: Tạo mã phiên duy nhất",
                file: "Tên File: Tạo tên file duy nhất",
                distributed: "Hệ Thống Phân Tán: Đảm bảo tính duy nhất",
            },
            versions: "Các Phiên Bản UUID",
            versionsList: {
                v4: {
                    title: "UUID v4 (Dựa trên ngẫu nhiên)",
                    desc: "UUID phiên bản 4 được tạo bằng các số ngẫu nhiên giả mạnh về mặt mật mã. Đây là phiên bản được áp dụng rộng rãi nhất trong các ứng dụng hiện đại do tính đơn giản và đặc tính duy nhất xuất sắc. Với 122 bit ngẫu nhiên, xác suất va chạm xấp xỉ 1 trong 2^122 (5,3 x 10^36), khiến việc tạo bản sao trùng lặp trong bất kỳ tình huống thực tế nào trở nên bất khả thi về mặt thống kê. UUID v4 lý tưởng cho các hệ thống phân tán nơi điều phối giữa các nút là không thực tế hoặc không thể. Các nền tảng lớn bao gồm java.util.UUID của Java, module uuid của Python và crypto.randomUUID() của JavaScript đều mặc định tạo version 4.",
                },
                v1: {
                    title: "UUID v1 (Dựa trên timestamp)",
                    desc: "UUID phiên bản 1 kết hợp timestamp hiện tại (đếm 60-bit các khoảng 100-nanosecond từ ngày 15 tháng 10 năm 1582) và địa chỉ MAC của máy tạo. Điều này đảm bảo tính duy nhất qua cả thời gian và không gian. Thành phần timestamp cho phép UUID được sắp xếp theo thứ tự thời gian, có thể cải thiện hiệu suất chỉ mục cơ sở dữ liệu. Tuy nhiên, UUID v1 có vấn đề về quyền riêng tư vì chúng để lộ địa chỉ MAC của máy tạo và thời gian tạo. Chúng thường được sử dụng trong các tình huống yêu cầu mã định danh được sắp xếp theo thời gian, chẳng hạn như ghi nhật ký sự kiện, cơ sở dữ liệu chuỗi thời gian và các hệ thống mà việc sắp xếp theo thứ tự thời gian là có lợi. Các triển khai hiện đại có thể sử dụng ID nút ngẫu nhiên thay vì địa chỉ MAC để giải quyết vấn đề về quyền riêng tư.",
                },
            },
            performance: "Hiệu Năng và Hiệu Quả UUID",
            performanceDesc:
                "Tạo UUID có chi phí tính toán rẻ và có thể tạo hàng triệu mã định danh mỗi giây trên phần cứng hiện đại. Tạo version 4 thường chỉ yêu cầu một lệnh gọi trình tạo số ngẫu nhiên mật mã, trong khi version 1 cần truy xuất timestamp và ID nút. Trong hệ thống cơ sở dữ liệu, UUID làm khóa chính cung cấp khả năng mở rộng tuyệt vời cho cơ sở dữ liệu phân tán và các tình huống sao chép đa master, loại bỏ nhu cầu tạo ID tập trung. Tuy nhiên, chúng lớn hơn số nguyên tự động tăng (128 bit so với 32-64 bit), có thể ảnh hưởng đến hiệu suất lưu trữ và chỉ mục. Bản chất ngẫu nhiên của UUID v4 có thể gây phân mảnh chỉ mục B-tree trong cơ sở dữ liệu quan hệ truyền thống, mặc dù điều này được giảm thiểu trong các công cụ cơ sở dữ liệu hiện đại với lưu trữ tối ưu hóa UUID. UUID tuần tự hoặc các biến thể UUID có thứ tự (như ULID hoặc UUID v6/v7) giải quyết hạn chế này trong khi vẫn duy trì đảm bảo tính duy nhất.",
            security: "Cân Nhắc Về Bảo Mật",
            securityDesc:
                "Tạo UUID v4 dựa vào trình tạo số ngẫu nhiên an toàn về mật mã (CSPRNG) để đảm bảo tính không thể đoán trước, khiến chúng phù hợp cho các ứng dụng nhạy cảm về bảo mật như token phiên, khóa API và token đặt lại mật khẩu. Entropy thiên văn học (2^122 kết hợp có thể) làm cho các cuộc tấn công vũ phu trở nên không khả thi về mặt tính toán. Tuy nhiên, nhà phát triển nên lưu ý rằng UUID không được thiết kế như những bí mật - chúng là mã định danh, không phải thông tin xác thực. UUID version 1 nên tránh trong các bối cảnh bảo mật vì chúng có thể đoán trước một phần và làm rò rỉ thông tin về thời gian tạo và phần cứng. Đối với các ứng dụng quan trọng về bảo mật yêu cầu cả tính duy nhất và không thể đoán trước, UUID v4 kết hợp với kiểm soát truy cập và mã hóa thích hợp cung cấp quản lý mã định danh mạnh mẽ. Tất cả việc tạo UUID trên công cụ này diễn ra hoàn toàn trong trình duyệt của bạn bằng Web Crypto API, đảm bảo mã định danh của bạn không bao giờ được truyền đến máy chủ bên ngoài.",
            faq: "Câu Hỏi Thường Gặp",
            faqList: {
                q1: "Khác biệt giữa UUID v1 và v4?",
                a1: "UUID v1 tạo mã định danh dựa trên timestamp (giá trị thời gian 60-bit) và địa chỉ MAC, đảm bảo tính duy nhất qua thời gian và không gian. Timestamp cho phép sắp xếp theo thứ tự thời gian, nhưng để lộ thời gian tạo và thông tin phần cứng. UUID v4 sử dụng số ngẫu nhiên mạnh về mật mã (122 bit ngẫu nhiên) để tạo, cung cấp quyền riêng tư và tính không thể đoán trước tốt hơn. V4 không trạng thái và đơn giản hơn để triển khai, khiến nó trở thành lựa chọn ưu tiên cho 95% ứng dụng hiện đại bao gồm dịch vụ web, microservices và ứng dụng đám mây.",
                q2: "UUID có thực sự duy nhất?",
                a2: "Có, UUID cung cấp đảm bảo tính duy nhất thực tế. Đối với UUID v4, với 122 bit ngẫu nhiên, xác suất tạo bản sao trùng lặp xấp xỉ 1 trong 5,3 × 10^36. Để hiểu rõ hơn, việc tạo một tỷ UUID mỗi giây trong 100 năm sẽ chỉ tạo ra xác suất va chạm là 0,0000000000005%. UUID v1 đảm bảo tính duy nhất thông qua độ chính xác timestamp (khoảng 100-nanosecond) và nhận dạng máy. Mặc dù về mặt lý thuyết có thể xảy ra va chạm trong v4, nhưng nó không thể xảy ra về mặt thống kê trong bất kỳ tình huống thực tế nào. Các công ty công nghệ lớn tạo hàng tỷ UUID mỗi ngày mà không gặp vấn đề va chạm.",
                q3: "Có thể dùng UUID làm khóa chính trong cơ sở dữ liệu?",
                a3: "Có, UUID là khóa chính tuyệt vời cho cơ sở dữ liệu phân tán và ứng dụng hiện đại. Lợi ích bao gồm: (1) Tạo phía client mà không cần truy vấn cơ sở dữ liệu, (2) Thân thiện với merge cho sao chép đa master, (3) Không có lỗ hổng dự đoán tuần tự, (4) Duy nhất toàn cầu trên tất cả bảng và cơ sở dữ liệu. Cân nhắc: UUID lớn hơn số nguyên (16 byte so với 4-8 byte), làm tăng kích thước lưu trữ và chỉ mục. UUID ngẫu nhiên có thể gây phân mảnh chỉ mục trong chỉ mục B-tree. Giải pháp hiện đại bao gồm UUID v6/v7 cho UUID theo thứ tự thời gian, hoặc tối ưu hóa cụ thể của cơ sở dữ liệu (kiểu UUID của PostgreSQL, UUID_TO_BIN() của MySQL). Các nền tảng lớn như MongoDB, Cassandra và DynamoDB sử dụng mã định danh giống UUID làm mặc định.",
                q4: "UUID dài bao nhiêu và định dạng là gì?",
                a4: "UUID có độ dài chính xác 128 bit (16 byte). Biểu diễn văn bản chuẩn là 36 ký tự: 32 chữ số thập lục phân (0-9, a-f) cộng 4 dấu gạch ngang theo định dạng 8-4-4-4-12 (ví dụ: 550e8400-e29b-41d4-a716-446655440000). Biểu diễn chuỗi sử dụng 36 byte lưu trữ, trong khi lưu trữ nhị phân sử dụng 16 byte. Năm nhóm đại diện cho: (1) time_low (8 chữ số hex), (2) time_mid (4 chữ số hex), (3) time_hi_and_version (4 chữ số hex), (4) clock_seq_and_reserved (4 chữ số hex), và (5) node (12 chữ số hex). Một số hệ thống sử dụng biểu diễn thay thế như mã hóa Base64 (22 ký tự) cho URL nhỏ gọn hơn.",
                q5: "Tạo UUID có an toàn và riêng tư không?",
                a5: "Tạo UUID v4 an toàn về mật mã khi sử dụng trình tạo số ngẫu nhiên thích hợp. Công cụ của chúng tôi sử dụng Web Crypto API (crypto.getRandomValues()) cung cấp số ngẫu nhiên mạnh về mật mã phù hợp cho các ứng dụng nhạy cảm về bảo mật. Tất cả việc tạo diễn ra hoàn toàn trong trình duyệt của bạn - không có dữ liệu nào được gửi đến máy chủ, đảm bảo quyền riêng tư hoàn toàn. Tuy nhiên, lưu ý quan trọng: (1) UUID là mã định danh, không phải bí mật hoặc mật khẩu - chúng có thể được hiển thị an toàn trong URL và API, (2) UUID v1 để lộ timestamp và có thể là địa chỉ MAC, giảm quyền riêng tư, (3) Đối với token xác thực, kết hợp UUID với kiểm soát truy cập thích hợp và hết hạn, (4) UUID đơn độc không cung cấp xác thực - chúng phải được xác thực phía máy chủ. Để có bảo mật tối đa: sử dụng v4, tạo phía máy chủ cho token, triển khai giới hạn tốc độ, và không bao giờ sử dụng UUID như cơ chế xác thực duy nhất.",
                q6: "Ưu điểm của UUID so với ID tự động tăng là gì?",
                a6: "UUID cung cấp nhiều ưu điểm: (1) Tính duy nhất toàn cầu mà không cần điều phối - có thể được tạo độc lập trên các hệ thống phân tán, (2) Không cần truy vấn cơ sở dữ liệu để tạo ID, cải thiện hiệu suất, (3) Thân thiện với merge cho sao chép và phân mảnh cơ sở dữ liệu, (4) Bảo mật - bản chất không tuần tự ngăn chặn các cuộc tấn công liệt kê, (5) Khả năng offline - ID có thể được tạo mà không cần kết nối cơ sở dữ liệu, (6) Linh hoạt - cùng một không gian ID có thể được sử dụng trên nhiều bảng và cơ sở dữ liệu. Đánh đổi bao gồm kích thước lưu trữ lớn hơn, phân mảnh chỉ mục tiềm năng và định dạng ít dễ đọc hơn cho con người. Tốt nhất cho: microservices, hệ thống phân tán, API công khai, ứng dụng offline-first. Sử dụng tự động tăng cho: hệ thống cơ sở dữ liệu đơn, dữ liệu được sắp xếp theo thứ tự thời gian, môi trường hạn chế lưu trữ.",
                q7: "Có thể tạo bao nhiêu UUID trước khi xảy ra va chạm?",
                a7: "Đối với UUID v4 với 122 bit ngẫu nhiên, bạn có thể tạo khoảng 2,71 × 10^18 (2,71 quintillion) UUID trước khi đạt xác suất 50% của một va chạm duy nhất. Để minh họa quy mô: tạo 1 nghìn tỷ (10^12) UUID dẫn đến xác suất va chạm chỉ 0,0000000000005%. Ngay cả khi mọi người trên Trái đất tạo 1 triệu UUID mỗi giây trong cả năm, xác suất va chạm vẫn không đáng kể. Nghịch lý sinh nhật áp dụng, nhưng không gian khóa khổng lồ làm cho va chạm không thể xảy ra về mặt thống kê cho bất kỳ ứng dụng thực tế nào. UUID v1 có đảm bảo mạnh mẽ hơn thông qua độ chính xác timestamp - hai UUID được tạo trên các máy khác nhau hoặc tại các thời điểm khác nhau (>100 nanosecond) được đảm bảo duy nhất.",
                q8: "Nên chọn phiên bản UUID nào?",
                a8: "Chọn UUID v4 cho 95% trường hợp sử dụng: ứng dụng web, API, microservices, ID phiên, mã định danh tài nguyên. Nó đơn giản, an toàn và cung cấp tính duy nhất xuất sắc. Sử dụng UUID v1 khi: (1) sắp xếp theo thứ tự thời gian quan trọng, (2) bạn cần trích xuất timestamp từ ID, (3) hiệu suất chỉ mục cơ sở dữ liệu với thứ tự thời gian là quan trọng. Tránh v1 nếu quyền riêng tư là mối quan tâm (để lộ địa chỉ MAC). Các lựa chọn mới nổi: UUID v6 (theo thứ tự thời gian như v1 nhưng được cải thiện), UUID v7 (dựa trên Unix timestamp, hiệu suất cơ sở dữ liệu tốt hơn), ULID (có thể sắp xếp theo từ điển, an toàn cho URL). Đối với các dự án mới năm 2025, hãy xem xét v4 cho sử dụng chung, v7 cho các ứng dụng nặng về cơ sở dữ liệu yêu cầu thứ tự thời gian, hoặc ULID để dễ đọc và sắp xếp hơn cho con người.",
            },
        },
    },
};
