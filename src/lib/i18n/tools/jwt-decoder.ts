export const jwtDecoderTranslations = {
    en: {
        name: "JWT Decoder",
        description: "Decode and inspect JSON Web Tokens",
        category: "Developer",
        decode: "Decode JWT",
        page: {
            title: "JWT Decoder",
            subtitle: "Decode and inspect JSON Web Tokens instantly",
            whatIs: "What is JWT?",
            whatIsDesc:
                "JWT (JSON Web Token) is an open standard (RFC 7519) for securely transmitting information between parties as a JSON object. This information can be verified and trusted because it is digitally signed using a secret (HMAC algorithm) or a public/private key pair (RSA or ECDSA). JWTs are widely used for authentication and information exchange in modern web applications, mobile apps, and APIs. First introduced in 2010 and standardized by the IETF in 2015, JWT has become the de facto standard for stateless authentication in distributed systems and microservices architectures.",
            history: "History and Evolution of JWT",
            historyDesc:
                "JSON Web Tokens emerged from the need for a compact, self-contained method of securely transmitting information in web applications. Before JWT, session-based authentication required server-side storage and lookup, limiting scalability. The JWT specification (RFC 7519) was published in May 2015, building on earlier standards like JSON Web Signature (JWS, RFC 7515) and JSON Web Encryption (JWE, RFC 7516). The standard was developed by the IETF JSON Web Token Working Group, led by Mike Jones from Microsoft, along with contributors from Google, Ping Identity, and others. JWT gained rapid adoption due to its simplicity, compactness, and ability to work seamlessly with RESTful APIs and Single Page Applications (SPAs). Today, JWT is supported by virtually every programming language and framework, with major platforms like Auth0, Firebase, AWS Cognito, and Okta using JWT as their primary token format.",
            structure: "JWT Structure and Components",
            structureDesc:
                "A JWT consists of three parts separated by dots (.): Header.Payload.Signature. The Header contains metadata about the token, typically the type (JWT) and signing algorithm (HS256, RS256, ES256, etc.). The Payload contains the claims - statements about an entity (typically the user) and additional metadata like expiration time (exp), issuer (iss), audience (aud), and custom claims. The Signature ensures the token hasn't been tampered with and verifies the sender's identity. Each part is Base64URL-encoded (not encrypted), making the token URL-safe. Example: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c. JWTs are typically 200-500 bytes, much smaller than XML-based tokens like SAML.",
            whyUse: "Why Use JWT Decoder?",
            features: {
                free: "Free unlimited JWT decoding",
                instant: "Instant decode and inspection",
                offline: "100% client-side, works offline",
                noServer: "No data sent to server, completely private",
                multiAlgo: "Supports all JWT algorithms",
                validation: "Validates JWT structure",
            },
            howToUse: "How to Use",
            steps: {
                step1: "Paste your JWT token into the input field",
                step2: "Click 'Decode JWT' button",
                step3: "View decoded header and payload",
                step4: "Inspect claims and verify token structure",
            },
            claims: "Common JWT Claims",
            claimsList: {
                iss: "iss (Issuer): Identifies who issued the token",
                sub: "sub (Subject): Identifies the subject of the token (usually user ID)",
                aud: "aud (Audience): Identifies the intended recipient(s)",
                exp: "exp (Expiration): Token expiration timestamp (Unix time)",
                nbf: "nbf (Not Before): Token not valid before this timestamp",
                iat: "iat (Issued At): When the token was issued",
                jti: "jti (JWT ID): Unique identifier for the token",
            },
            algorithms: "JWT Signing Algorithms",
            algorithmsList: {
                hs256: {
                    title: "HS256 (HMAC SHA-256)",
                    desc: "Symmetric algorithm using a shared secret key. Fast and simple, ideal for internal APIs where both issuer and verifier share the same secret. Requires secure key distribution. Most commonly used algorithm, supported by all JWT libraries. Key size: 256 bits minimum.",
                },
                rs256: {
                    title: "RS256 (RSA SHA-256)",
                    desc: "Asymmetric algorithm using RSA public/private key pair. The token is signed with a private key and verified with a public key. Ideal for scenarios where token issuers and verifiers are different parties (e.g., OAuth, OpenID Connect). Public key can be safely distributed. More CPU-intensive than HMAC. Key size: 2048 bits minimum (recommended 4096 bits).",
                },
                es256: {
                    title: "ES256 (ECDSA SHA-256)",
                    desc: "Asymmetric algorithm using Elliptic Curve cryptography. Provides same security as RSA with smaller key sizes and signatures, resulting in smaller tokens and better performance. Growing in popularity for mobile and IoT applications. Supported by modern JWT libraries. Key size: 256 bits provides equivalent security to RSA 3072 bits.",
                },
            },
            useCases: "Common Use Cases",
            useCasesList: {
                auth: "Authentication: Stateless user authentication in web and mobile apps",
                api: "API Authorization: Secure API access with bearer tokens",
                sso: "Single Sign-On (SSO): Share authentication across multiple applications",
                oauth: "OAuth 2.0: Standard token format for OAuth flows",
                microservices: "Microservices: Pass user context between services",
                mobile: "Mobile Apps: Persistent authentication without sessions",
            },
            security: "Security Best Practices",
            securityDesc:
                "JWT security is critical for application safety. Always validate the signature to prevent token tampering. Use strong secrets (minimum 256 bits for HMAC) or proper key management for asymmetric algorithms. Always verify 'exp' (expiration) claim to prevent token replay attacks. Use short expiration times (15-60 minutes) for access tokens and refresh tokens for extended sessions. Never store sensitive data in JWT payload as it's Base64-encoded, not encrypted - anyone can decode it. Use HTTPS to prevent token interception during transmission. Implement token revocation for logout and security events, using blacklists or short-lived tokens. Validate 'aud' (audience) and 'iss' (issuer) claims to prevent token misuse. Consider using JWE (JSON Web Encryption) for sensitive payload data. Rotate signing keys regularly. Be aware of algorithm confusion attacks - always verify the algorithm matches expectations. This decoder tool runs entirely in your browser - tokens are never transmitted to any server.",
            performance: "JWT Performance and Efficiency",
            performanceDesc:
                "JWT offers excellent performance characteristics for modern applications. Token validation is extremely fast as it only requires signature verification using cryptographic algorithms, typically completing in microseconds. Unlike session-based authentication requiring database lookups, JWT validation is stateless and O(1) constant time. This makes JWT ideal for high-traffic applications and microservices. Token size ranges from 200-500 bytes for typical payloads, which is negligible for modern networks. However, large payloads can impact performance - keep claims minimal. HMAC algorithms (HS256) are faster than RSA (RS256), processing 10-100x more tokens per second on the same hardware. ECDSA (ES256) provides a good balance between security and performance. For optimal performance: use short-lived tokens, cache public keys for RSA/ECDSA validation, consider token compression for very large payloads, and implement token refresh strategies to minimize re-authentication overhead.",
            faq: "Frequently Asked Questions",
            faqList: {
                q1: "What's the difference between JWT and session-based authentication?",
                a1: "JWT is stateless - all user information is contained in the token itself, requiring no server-side session storage. Sessions require server memory/database to store session data, limiting horizontal scalability. JWT tokens can be verified by any service with the secret/public key, making them ideal for distributed systems and microservices. Sessions require sticky sessions or shared session storage in load-balanced environments. JWT enables true stateless REST APIs. However, sessions are easier to revoke immediately, while JWT requires additional mechanisms like token blacklisting. JWT is better for: APIs, microservices, mobile apps, cross-domain authentication. Sessions are better for: traditional web apps, scenarios requiring immediate logout, highly sensitive applications.",
                q2: "Is JWT secure? Can it be tampered with?",
                a2: "JWT is cryptographically secure when properly implemented. The signature ensures that any modification to the header or payload will invalidate the token. However, the payload is only Base64-encoded, not encrypted - anyone can decode and read it. Never store sensitive information like passwords or credit card numbers in JWT. Use HTTPS to prevent token interception. The security depends on: (1) Secret key strength - use minimum 256-bit random keys for HMAC, (2) Algorithm verification - always validate the algorithm to prevent 'none' algorithm attacks, (3) Expiration validation - always check 'exp' claim, (4) Signature verification - never skip signature validation. Common vulnerabilities: weak secrets, algorithm confusion attacks, missing expiration checks, storing tokens in localStorage (XSS vulnerability). Best practice: store in httpOnly cookies or memory for SPAs.",
                q3: "Why can I decode JWT without a secret key?",
                a3: "JWT payload is Base64URL-encoded, not encrypted. This is by design - encoding makes the token URL-safe and allows anyone to read the contents. The signature prevents tampering, not reading. Think of JWT like a sealed envelope: you can see the outside (header and payload), but can't modify the contents without breaking the seal (signature). This design allows: (1) Receivers to read claims before verification, (2) Debugging and troubleshooting, (3) Client-side decision making based on claims, (4) Faster processing as encryption/decryption isn't needed. If you need to hide the payload contents, use JWE (JSON Web Encryption) which encrypts the entire token. For most use cases, encoding is sufficient as the signature prevents malicious modifications.",
                q4: "What happens when JWT expires?",
                a4: "When a JWT's 'exp' (expiration) claim passes, the token becomes invalid and should be rejected by the server. The application should handle this by: (1) Returning 401 Unauthorized error, (2) Prompting the user to re-authenticate, or (3) Using a refresh token to obtain a new access token. Typical JWT architecture uses two tokens: short-lived access tokens (15-60 minutes) for API requests, and long-lived refresh tokens (days/weeks) for obtaining new access tokens. This balances security (short access token lifetime limits damage if compromised) with user experience (users don't re-login frequently). Implementation: Client receives both tokens → Uses access token for API calls → When access token expires, uses refresh token to get new access token → Repeats until refresh token expires or user logs out. Never extend JWT expiration on the client side - 'exp' is cryptographically signed.",
                q5: "Can I revoke or invalidate a JWT before it expires?",
                a5: "JWT tokens are stateless, so immediate revocation is challenging. However, several strategies exist: (1) Token Blacklist - maintain a list of revoked tokens (identified by 'jti' claim) in Redis or database, check before validating. Fast but requires storage. (2) Short expiration times - 5-15 minute tokens limit exposure window. Combine with refresh tokens. (3) Version claims - include user version number in token, increment on logout/password change, reject old versions. (4) Real-time validation - check user status in database on each request (defeats stateless benefits). (5) Event-driven invalidation - notify all services when user logs out. Best practice: Combine short-lived tokens (15-60 min) with refresh token rotation. When user logs out, blacklist refresh token and wait for access token to expire naturally. For critical security events (password change, suspicious activity), implement immediate blacklist checking.",
                q6: "Should I store JWT in localStorage or cookies?",
                a6: "Both have trade-offs. httpOnly cookies are more secure: not accessible to JavaScript (prevents XSS attacks), automatically included in requests, can use SameSite attribute for CSRF protection. However, cookies are vulnerable to CSRF attacks (mitigated with SameSite and CSRF tokens) and don't work well for cross-domain requests. localStorage is vulnerable to XSS attacks - any JavaScript can access it, making XSS attacks more dangerous. Benefits: works across domains, easier implementation for SPAs, full JavaScript control. Best practices: (1) For web apps: Use httpOnly, secure, SameSite cookies for maximum security, (2) For SPAs/mobile: Store in memory (state management) and use refresh tokens in httpOnly cookies, (3) Never use localStorage for sensitive tokens in production, (4) Implement Content Security Policy (CSP) to mitigate XSS, (5) For cross-domain: Use OAuth/OIDC flows with proper CORS configuration. Modern recommendation: httpOnly cookies for web apps, memory + secure refresh mechanism for SPAs.",
                q7: "What's the maximum size of a JWT token?",
                a7: "JWT has no strict size limit in the specification, but practical limits exist. Recommended maximum: 4KB-8KB to fit in HTTP headers. Browser URL limits: ~2KB (if passed in URL). Cookie limits: 4KB per cookie. HTTP header limits: typically 8KB-16KB depending on server. Larger tokens cause: (1) Performance degradation - larger network transfers, (2) Header size errors if too large, (3) Cookie rejection by browsers, (4) Slower parsing and validation. Typical JWT sizes: Minimal token (sub, exp, iat): ~200 bytes. Standard token with common claims: ~300-500 bytes. Token with custom claims: ~500-1000 bytes. Keep tokens small by: (1) Using claim abbreviations (avoid long claim names), (2) Not including large arrays or objects, (3) Referencing data by ID rather than embedding, (4) Using separate API calls for large data. If you need large payloads, store data server-side and include only a reference ID in the token.",
                q8: "What JWT signing algorithm should I use?",
                a8: "Choice depends on your use case: HS256 (HMAC SHA-256): Best for internal APIs where issuer and verifier are the same system or trusted parties sharing a secret. Pros: Fast, simple, well-supported. Cons: Requires secure secret distribution. Use when: microservices within same organization, simple applications, performance is critical. RS256 (RSA SHA-256): Best for distributed systems where token issuers and verifiers are different parties. Pros: Public key can be safely shared, widely supported in OAuth/OIDC. Cons: Slower than HMAC, requires key management. Use when: public APIs, OAuth 2.0, OpenID Connect, multi-tenant systems. ES256 (ECDSA SHA-256): Best for modern applications needing smaller tokens and better performance than RSA. Pros: Smaller signatures, faster than RSA, strong security. Cons: Less universally supported than RS256. Use when: mobile apps, IoT, performance-critical systems. Recommendation for 2025: ES256 for new projects, RS256 for OAuth/OIDC compatibility, HS256 for internal services. Avoid: 'none' (no signature), weak algorithms (HS1, RS1).",
            },
        },
    },
    vi: {
        name: "Giải Mã JWT",
        description: "Giải mã và kiểm tra JSON Web Token",
        category: "Lập Trình",
        decode: "Giải Mã JWT",
        page: {
            title: "Giải Mã JWT",
            subtitle: "Giải mã và kiểm tra JSON Web Token ngay lập tức",
            whatIs: "JWT Là Gì?",
            whatIsDesc:
                "JWT (JSON Web Token) là một tiêu chuẩn mở (RFC 7519) để truyền thông tin an toàn giữa các bên dưới dạng đối tượng JSON. Thông tin này có thể được xác minh và tin cậy vì nó được ký số bằng secret (thuật toán HMAC) hoặc cặp khóa công khai/riêng tư (RSA hoặc ECDSA). JWT được sử dụng rộng rãi cho xác thực và trao đổi thông tin trong các ứng dụng web hiện đại, ứng dụng di động và API. Lần đầu tiên được giới thiệu vào năm 2010 và được chuẩn hóa bởi IETF vào năm 2015, JWT đã trở thành tiêu chuẩn de facto cho xác thực stateless trong các hệ thống phân tán và kiến trúc microservices.",
            history: "Lịch Sử và Phát Triển JWT",
            historyDesc:
                "JSON Web Token xuất hiện từ nhu cầu về một phương pháp nhỏ gọn, độc lập để truyền thông tin an toàn trong các ứng dụng web. Trước JWT, xác thực dựa trên session yêu cầu lưu trữ và tra cứu phía máy chủ, hạn chế khả năng mở rộng. Đặc tả JWT (RFC 7519) được xuất bản vào tháng 5 năm 2015, dựa trên các tiêu chuẩn trước đó như JSON Web Signature (JWS, RFC 7515) và JSON Web Encryption (JWE, RFC 7516). Tiêu chuẩn được phát triển bởi IETF JSON Web Token Working Group, do Mike Jones từ Microsoft dẫn đầu, cùng với những người đóng góp từ Google, Ping Identity và các công ty khác. JWT được chấp nhận nhanh chóng do tính đơn giản, nhỏ gọn và khả năng hoạt động liền mạch với RESTful API và Single Page Applications (SPA). Ngày nay, JWT được hỗ trợ bởi hầu như mọi ngôn ngữ lập trình và framework, với các nền tảng lớn như Auth0, Firebase, AWS Cognito và Okta sử dụng JWT làm định dạng token chính.",
            structure: "Cấu Trúc và Thành Phần JWT",
            structureDesc:
                "JWT bao gồm ba phần được phân tách bằng dấu chấm (.): Header.Payload.Signature. Header chứa metadata về token, thường là loại (JWT) và thuật toán ký (HS256, RS256, ES256, v.v.). Payload chứa các claims - tuyên bố về một thực thể (thường là người dùng) và metadata bổ sung như thời gian hết hạn (exp), issuer (iss), audience (aud) và custom claims. Signature đảm bảo token không bị giả mạo và xác minh danh tính người gửi. Mỗi phần được mã hóa Base64URL (không phải mã hóa), làm cho token an toàn cho URL. Ví dụ: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c. JWT thường có kích thước 200-500 byte, nhỏ hơn nhiều so với token dựa trên XML như SAML.",
            whyUse: "Tại Sao Dùng Giải Mã JWT?",
            features: {
                free: "Miễn phí giải mã JWT không giới hạn",
                instant: "Giải mã và kiểm tra tức thì",
                offline: "100% client-side, hoạt động offline",
                noServer: "Không gửi dữ liệu đến server, hoàn toàn riêng tư",
                multiAlgo: "Hỗ trợ tất cả thuật toán JWT",
                validation: "Xác thực cấu trúc JWT",
            },
            howToUse: "Cách Sử Dụng",
            steps: {
                step1: "Dán JWT token vào ô nhập liệu",
                step2: "Nhấp nút 'Giải Mã JWT'",
                step3: "Xem header và payload đã giải mã",
                step4: "Kiểm tra claims và xác minh cấu trúc token",
            },
            claims: "Các Claims Phổ Biến trong JWT",
            claimsList: {
                iss: "iss (Issuer): Xác định ai đã phát hành token",
                sub: "sub (Subject): Xác định chủ thể của token (thường là user ID)",
                aud: "aud (Audience): Xác định người nhận dự định",
                exp: "exp (Expiration): Timestamp hết hạn token (Unix time)",
                nbf: "nbf (Not Before): Token không hợp lệ trước timestamp này",
                iat: "iat (Issued At): Khi token được phát hành",
                jti: "jti (JWT ID): Mã định danh duy nhất cho token",
            },
            algorithms: "Thuật Toán Ký JWT",
            algorithmsList: {
                hs256: {
                    title: "HS256 (HMAC SHA-256)",
                    desc: "Thuật toán đối xứng sử dụng khóa bí mật chung. Nhanh và đơn giản, lý tưởng cho API nội bộ nơi cả issuer và verifier chia sẻ cùng secret. Yêu cầu phân phối khóa an toàn. Thuật toán được sử dụng phổ biến nhất, được hỗ trợ bởi tất cả thư viện JWT. Kích thước khóa: tối thiểu 256 bit.",
                },
                rs256: {
                    title: "RS256 (RSA SHA-256)",
                    desc: "Thuật toán bất đối xứng sử dụng cặp khóa công khai/riêng tư RSA. Token được ký bằng khóa riêng tư và xác minh bằng khóa công khai. Lý tưởng cho các tình huống mà người phát hành và xác minh token là các bên khác nhau (ví dụ: OAuth, OpenID Connect). Khóa công khai có thể được phân phối an toàn. Tốn CPU hơn HMAC. Kích thước khóa: tối thiểu 2048 bit (khuyến nghị 4096 bit).",
                },
                es256: {
                    title: "ES256 (ECDSA SHA-256)",
                    desc: "Thuật toán bất đối xứng sử dụng mật mã đường cong Elliptic. Cung cấp cùng mức bảo mật như RSA với kích thước khóa và chữ ký nhỏ hơn, tạo ra token nhỏ hơn và hiệu suất tốt hơn. Ngày càng phổ biến cho ứng dụng di động và IoT. Được hỗ trợ bởi các thư viện JWT hiện đại. Kích thước khóa: 256 bit cung cấp bảo mật tương đương RSA 3072 bit.",
                },
            },
            useCases: "Trường Hợp Sử Dụng Phổ Biến",
            useCasesList: {
                auth: "Xác Thực: Xác thực người dùng stateless trong web và mobile app",
                api: "Ủy Quyền API: Truy cập API an toàn với bearer token",
                sso: "Single Sign-On (SSO): Chia sẻ xác thực trên nhiều ứng dụng",
                oauth: "OAuth 2.0: Định dạng token chuẩn cho OAuth flow",
                microservices: "Microservices: Truyền context người dùng giữa các service",
                mobile: "Mobile App: Xác thực bền vững không cần session",
            },
            security: "Best Practices Bảo Mật",
            securityDesc:
                "Bảo mật JWT rất quan trọng cho an toàn ứng dụng. Luôn xác thực chữ ký để ngăn chặn giả mạo token. Sử dụng secret mạnh (tối thiểu 256 bit cho HMAC) hoặc quản lý khóa thích hợp cho thuật toán bất đối xứng. Luôn xác minh claim 'exp' (expiration) để ngăn chặn tấn công replay token. Sử dụng thời gian hết hạn ngắn (15-60 phút) cho access token và refresh token cho phiên mở rộng. Không bao giờ lưu dữ liệu nhạy cảm trong JWT payload vì nó được mã hóa Base64, không phải mã hóa - bất kỳ ai cũng có thể giải mã. Sử dụng HTTPS để ngăn chặn chặn token trong quá trình truyền. Triển khai thu hồi token cho logout và sự kiện bảo mật, sử dụng blacklist hoặc token ngắn hạn. Xác thực claim 'aud' (audience) và 'iss' (issuer) để ngăn chặn lạm dụng token. Cân nhắc sử dụng JWE (JSON Web Encryption) cho dữ liệu payload nhạy cảm. Xoay khóa ký thường xuyên. Cẩn thận với tấn công nhầm lẫn thuật toán - luôn xác minh thuật toán khớp với kỳ vọng. Công cụ giải mã này chạy hoàn toàn trong trình duyệt của bạn - token không bao giờ được truyền đến bất kỳ máy chủ nào.",
            performance: "Hiệu Năng và Hiệu Quả JWT",
            performanceDesc:
                "JWT cung cấp đặc tính hiệu suất tuyệt vời cho các ứng dụng hiện đại. Xác thực token cực kỳ nhanh vì nó chỉ yêu cầu xác minh chữ ký bằng thuật toán mật mã, thường hoàn thành trong micro giây. Không giống như xác thực dựa trên session yêu cầu tra cứu cơ sở dữ liệu, xác thực JWT là stateless và thời gian hằng số O(1). Điều này làm cho JWT lý tưởng cho các ứng dụng lưu lượng cao và microservices. Kích thước token dao động từ 200-500 byte cho payload điển hình, không đáng kể cho mạng hiện đại. Tuy nhiên, payload lớn có thể ảnh hưởng đến hiệu suất - giữ claim tối thiểu. Thuật toán HMAC (HS256) nhanh hơn RSA (RS256), xử lý 10-100 lần token hơn mỗi giây trên cùng phần cứng. ECDSA (ES256) cung cấp sự cân bằng tốt giữa bảo mật và hiệu suất. Để có hiệu suất tối ưu: sử dụng token ngắn hạn, cache khóa công khai cho xác thực RSA/ECDSA, cân nhắc nén token cho payload rất lớn và triển khai chiến lược làm mới token để giảm thiểu overhead xác thực lại.",
            faq: "Câu Hỏi Thường Gặp",
            faqList: {
                q1: "Khác biệt giữa JWT và xác thực dựa trên session?",
                a1: "JWT là stateless - tất cả thông tin người dùng được chứa trong chính token, không yêu cầu lưu trữ session phía máy chủ. Session yêu cầu bộ nhớ/cơ sở dữ liệu máy chủ để lưu trữ dữ liệu session, hạn chế khả năng mở rộng theo chiều ngang. Token JWT có thể được xác minh bởi bất kỳ dịch vụ nào có secret/khóa công khai, làm cho chúng lý tưởng cho hệ thống phân tán và microservices. Session yêu cầu sticky session hoặc lưu trữ session được chia sẻ trong môi trường cân bằng tải. JWT cho phép REST API stateless thực sự. Tuy nhiên, session dễ thu hồi ngay lập tức hơn, trong khi JWT yêu cầu cơ chế bổ sung như blacklist token. JWT tốt hơn cho: API, microservices, mobile app, xác thực cross-domain. Session tốt hơn cho: web app truyền thống, tình huống yêu cầu logout ngay lập tức, ứng dụng rất nhạy cảm.",
                q2: "JWT có an toàn không? Có thể bị giả mạo không?",
                a2: "JWT an toàn về mặt mật mã khi được triển khai đúng cách. Chữ ký đảm bảo rằng bất kỳ sửa đổi nào đối với header hoặc payload sẽ làm token không hợp lệ. Tuy nhiên, payload chỉ được mã hóa Base64, không phải mã hóa - bất kỳ ai cũng có thể giải mã và đọc nó. Không bao giờ lưu trữ thông tin nhạy cảm như mật khẩu hoặc số thẻ tín dụng trong JWT. Sử dụng HTTPS để ngăn chặn chặn token. Bảo mật phụ thuộc vào: (1) Độ mạnh khóa secret - sử dụng khóa ngẫu nhiên tối thiểu 256-bit cho HMAC, (2) Xác minh thuật toán - luôn xác thực thuật toán để ngăn chặn tấn công thuật toán 'none', (3) Xác thực hết hạn - luôn kiểm tra claim 'exp', (4) Xác minh chữ ký - không bao giờ bỏ qua xác thực chữ ký. Lỗ hổng phổ biến: secret yếu, tấn công nhầm lẫn thuật toán, thiếu kiểm tra hết hạn, lưu token trong localStorage (lỗ hổng XSS). Best practice: lưu trong httpOnly cookie hoặc memory cho SPA.",
                q3: "Tại sao tôi có thể giải mã JWT mà không cần khóa secret?",
                a3: "JWT payload được mã hóa Base64URL, không phải mã hóa. Đây là thiết kế - mã hóa làm cho token an toàn cho URL và cho phép bất kỳ ai đọc nội dung. Chữ ký ngăn chặn giả mạo, không phải đọc. Nghĩ về JWT như một phong bì niêm phong: bạn có thể thấy bên ngoài (header và payload), nhưng không thể sửa đổi nội dung mà không phá vỡ con dấu (chữ ký). Thiết kế này cho phép: (1) Người nhận đọc claim trước khi xác minh, (2) Debug và khắc phục sự cố, (3) Ra quyết định phía client dựa trên claim, (4) Xử lý nhanh hơn vì không cần mã hóa/giải mã. Nếu bạn cần ẩn nội dung payload, sử dụng JWE (JSON Web Encryption) để mã hóa toàn bộ token. Đối với hầu hết trường hợp sử dụng, mã hóa là đủ vì chữ ký ngăn chặn sửa đổi độc hại.",
                q4: "Điều gì xảy ra khi JWT hết hạn?",
                a4: "Khi claim 'exp' (expiration) của JWT qua, token trở nên không hợp lệ và nên bị máy chủ từ chối. Ứng dụng nên xử lý điều này bằng cách: (1) Trả về lỗi 401 Unauthorized, (2) Nhắc người dùng xác thực lại, hoặc (3) Sử dụng refresh token để lấy access token mới. Kiến trúc JWT điển hình sử dụng hai token: access token ngắn hạn (15-60 phút) cho yêu cầu API, và refresh token dài hạn (ngày/tuần) để lấy access token mới. Điều này cân bằng bảo mật (thời gian access token ngắn hạn hạn chế thiệt hại nếu bị xâm phạm) với trải nghiệm người dùng (người dùng không đăng nhập lại thường xuyên). Triển khai: Client nhận cả hai token → Sử dụng access token cho API call → Khi access token hết hạn, sử dụng refresh token để lấy access token mới → Lặp lại cho đến khi refresh token hết hạn hoặc người dùng đăng xuất. Không bao giờ mở rộng hết hạn JWT ở phía client - 'exp' được ký mật mã.",
                q5: "Có thể thu hồi hoặc làm token JWT không hợp lệ trước khi hết hạn?",
                a5: "Token JWT là stateless, vì vậy thu hồi ngay lập tức là thách thức. Tuy nhiên, có nhiều chiến lược: (1) Token Blacklist - duy trì danh sách token bị thu hồi (được xác định bởi claim 'jti') trong Redis hoặc database, kiểm tra trước khi xác thực. Nhanh nhưng yêu cầu lưu trữ. (2) Thời gian hết hạn ngắn - token 5-15 phút hạn chế cửa sổ phơi nhiễm. Kết hợp với refresh token. (3) Version claim - bao gồm số phiên bản người dùng trong token, tăng khi logout/thay đổi mật khẩu, từ chối phiên bản cũ. (4) Xác thực thời gian thực - kiểm tra trạng thái người dùng trong database trên mỗi yêu cầu (đánh bại lợi ích stateless). (5) Invalidation theo sự kiện - thông báo tất cả dịch vụ khi người dùng đăng xuất. Best practice: Kết hợp token ngắn hạn (15-60 phút) với xoay refresh token. Khi người dùng đăng xuất, blacklist refresh token và đợi access token hết hạn tự nhiên. Đối với sự kiện bảo mật quan trọng (thay đổi mật khẩu, hoạt động đáng ngờ), triển khai kiểm tra blacklist ngay lập tức.",
                q6: "Nên lưu JWT trong localStorage hay cookie?",
                a6: "Cả hai đều có đánh đổi. httpOnly cookie an toàn hơn: không thể truy cập bằng JavaScript (ngăn chặn tấn công XSS), tự động bao gồm trong yêu cầu, có thể sử dụng thuộc tính SameSite để bảo vệ CSRF. Tuy nhiên, cookie dễ bị tấn công CSRF (giảm thiểu bằng SameSite và CSRF token) và không hoạt động tốt cho yêu cầu cross-domain. localStorage dễ bị tấn công XSS - bất kỳ JavaScript nào cũng có thể truy cập nó, làm cho tấn công XSS nguy hiểm hơn. Lợi ích: hoạt động cross-domain, triển khai dễ dàng hơn cho SPA, kiểm soát JavaScript đầy đủ. Best practice: (1) Cho web app: Sử dụng httpOnly, secure, SameSite cookie để có bảo mật tối đa, (2) Cho SPA/mobile: Lưu trong memory (state management) và sử dụng refresh token trong httpOnly cookie, (3) Không bao giờ sử dụng localStorage cho token nhạy cảm trong production, (4) Triển khai Content Security Policy (CSP) để giảm thiểu XSS, (5) Cho cross-domain: Sử dụng OAuth/OIDC flow với CORS config thích hợp. Khuyến nghị hiện đại: httpOnly cookie cho web app, memory + cơ chế refresh an toàn cho SPA.",
                q7: "Kích thước tối đa của JWT token là bao nhiêu?",
                a7: "JWT không có giới hạn kích thước nghiêm ngặt trong đặc tả, nhưng có giới hạn thực tế. Khuyến nghị tối đa: 4KB-8KB để vừa trong HTTP header. Giới hạn URL trình duyệt: ~2KB (nếu truyền trong URL). Giới hạn cookie: 4KB mỗi cookie. Giới hạn HTTP header: thường 8KB-16KB tùy thuộc vào máy chủ. Token lớn hơn gây ra: (1) Suy giảm hiệu suất - truyền mạng lớn hơn, (2) Lỗi kích thước header nếu quá lớn, (3) Cookie bị trình duyệt từ chối, (4) Phân tích và xác thực chậm hơn. Kích thước JWT điển hình: Token tối thiểu (sub, exp, iat): ~200 byte. Token chuẩn với claim phổ biến: ~300-500 byte. Token với custom claim: ~500-1000 byte. Giữ token nhỏ bằng cách: (1) Sử dụng viết tắt claim (tránh tên claim dài), (2) Không bao gồm mảng hoặc đối tượng lớn, (3) Tham chiếu dữ liệu bằng ID thay vì nhúng, (4) Sử dụng API call riêng cho dữ liệu lớn. Nếu bạn cần payload lớn, lưu dữ liệu phía máy chủ và chỉ bao gồm ID tham chiếu trong token.",
                q8: "Nên sử dụng thuật toán ký JWT nào?",
                a8: "Lựa chọn phụ thuộc vào trường hợp sử dụng của bạn: HS256 (HMAC SHA-256): Tốt nhất cho API nội bộ nơi issuer và verifier là cùng hệ thống hoặc các bên đáng tin cậy chia sẻ secret. Ưu điểm: Nhanh, đơn giản, được hỗ trợ tốt. Nhược điểm: Yêu cầu phân phối secret an toàn. Sử dụng khi: microservices trong cùng tổ chức, ứng dụng đơn giản, hiệu suất quan trọng. RS256 (RSA SHA-256): Tốt nhất cho hệ thống phân tán nơi token issuer và verifier là các bên khác nhau. Ưu điểm: Khóa công khai có thể được chia sẻ an toàn, được hỗ trợ rộng rãi trong OAuth/OIDC. Nhược điểm: Chậm hơn HMAC, yêu cầu quản lý khóa. Sử dụng khi: API công khai, OAuth 2.0, OpenID Connect, hệ thống multi-tenant. ES256 (ECDSA SHA-256): Tốt nhất cho ứng dụng hiện đại cần token nhỏ hơn và hiệu suất tốt hơn RSA. Ưu điểm: Chữ ký nhỏ hơn, nhanh hơn RSA, bảo mật mạnh. Nhược điểm: Ít được hỗ trợ phổ biến hơn RS256. Sử dụng khi: mobile app, IoT, hệ thống quan trọng về hiệu suất. Khuyến nghị cho 2025: ES256 cho dự án mới, RS256 cho tương thích OAuth/OIDC, HS256 cho dịch vụ nội bộ. Tránh: 'none' (không chữ ký), thuật toán yếu (HS1, RS1).",
            },
        },
    },
};
